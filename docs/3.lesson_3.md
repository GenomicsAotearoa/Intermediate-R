# Tidy iteration and data storage

## The `map_*` family

Learning objectives:

* Understand the anatomy of `map_*` family of functions
* Understand anonymous functions
* Be able to use `map_*` and its variations for iteration
* Efficiently manipulate list components

In the previous section, we have seen how to use loops to repetitively perform tasks. However, there is a suite of functions provided by the `purrr` package that can do that, but with fewer lines of code! These are the `map_*` family of functions. These are functions that iterate through $n$ number of vectors (recall that lists are vectors).

<!-- needs image from purrr's cheat sheet -->

| `map_*` functions | Number of vectors |
| ----------------- | ----------------- |
| `map_*`           | 1                 |
| `map2_*`          | 2                 |
| `pmap_*`          | > 2               |

??? `imap_*` over a vector and it's index/name

    Besides the aforementioned `map_*` family of functions, there is also `imap_*` that iterates through a vector and it's index or name. Personally, I don't use it often as I think `map2_*` and `pmap_*` is more than sufficient (and more flexible).

The functions above always outputs a list. However, there are also modifiers you can use that can produce different kinds of outputs:

| Modifiers | Expected output type |
| --------- | -------------------- |
| `_chr`    | Character            |
| `_dbl`    | Double               |
| `_lgl`    | Boolean              |
| `_int`    | Integer              |

??? `_dfc` or `_dfr` 

    There are variations where the output is turned into a data frame using column- or row-bind. This is helpful if you are at the end of testing your code and you know exactly how the outputs need to be organised. However, for initial exploratory analysis, I find myself using `bind_rows()` or `bind_cols()` more often after the `map()`/`pmap()`.

Personally, I use `map()` and `pmap()` in all my analyses as it is flexible for many (if not all) use case scenarios.

Henceforth, I will use `map_*()` to mean all variations of map functions (including `pmap` and `map2`)

### Anatomy of `map_*()`

All `map_*()` functions require two arguments:

* A vector, this includes lists and data frames
* A function

```r
map(vec, my_function(x) do_something(x))
map2(vec_A, vec_B, my_function(x) do_something(x, y))
pmap(list(vec_A, vec_B, vec_C), my_function(x, y, z) do_something(x, y, z))
```

**Anonymous functions and alternative notation**

In the previous lesson, we looked at how to assign a block of code that performs some task (calculate diversity indices) to a variable. This makes the object a function. However, what if you only need to use the function once, perhaps as a form of convenience? In that case you can write an anonymous function, which is to say a function that is not assigned a variable name. For example:

```r
vec_A <- rnorm(10)
vec_B <- rnorm(10, sd = 2.5)

map2(vec_A, vec_B, function(x, y) {x * y})
```

The above function written inside the `map2()` call is not assigned. However, it produces the desired output as expected of a function. This is known as an anonymous function. 

There are also alternative notations (or shorthand) to specify functions. In base R, you can replace the word `function` with a backslash and it will behave the same way. 

```r
a_function <- \(x, y) {x + y}

a_function(1, 4)
```

In `purrr`, there is also another way to indicate functions via shorthand:

```r
map(1:4, ~ .x ^ 2)
map2(1:4, 2:5, ~ .x * .y)
pmap(list(rnorm(4), rnorm(4), rnorm(4)), ~ ..1 * ..2 + ..3)
```

The above is equivalent to:

```r
map(1:4, function(x) x ^ 2)
map2(1:4, 2:5, function(x, y) x * y)
pmap(list(rnorm(4), rnorm(4), rnorm(4)), function(x, y, z) x * y + z)
```

!!! question "`for` loop or `map_*()`?"

    In older versions of R, the general advice leaned towards using vectorised iterations such as `map_*()` (or `apply()` family of functions from base R). This is due to the runtime of a `for` loop being slower. New versions of R have fixed that and is now about on par with these vectorised functions. There is a specific case where a `for` loop is favoured:
    
    * **Uneven number of elements** `map2()` and `pmap()` requires that all lists in the arguments have the same number of elements. This is not a requirement in a `for` loop. You can iterate through as many lists of different sizes in as many nested constructs as you want! The trade-off is that it does take a little bit more set-up to allocate output sizes and how you would like the output to look.

    In many use cases, `map_*()` is likely sufficient. Some pros of using `map_*()` as opposed to a `for` loop are:

    * **Readability** The vectorised nature of the functions means that code is more concise. As all nested outputs can be stored as list specified within the function (anonymous or not) to be iterated, there is no need to remember indices!
    * **Control of output types** You can use the different variations of `map_*()` to control what types/mode of outputs you want. During interactive coding, this can help you troubleshoot potential problems early on. Unlike coercion, `map_*()` will not produce an output if the resultant object is not of the type specified. Thus, it ensures data type/mode consistency when the output is used for other downstream processes should you need to scale the input/output data.

### Playing with `map_*()`

**Reading multiple files**

This is one use case of `map()` where I can load many files generated from a software all at once. There are instances that bioinformatic analyses can be run in parallel, thus suitable for array-type HPC jobs. If we planned ahead prior to running bioinformatic analyses and standardised all output filenames, we can combine string matching operations and iterations to load these files all at once!

Here, we are loading 2 UniFrac distance matrices:

* `unweighted_unifrac.dist` which is the community phylogenetic distance
* `weighted_unifrac.dist` which is the the same distance weighted by relative abundance 

!!! r-project "code"

    ```r
    # Find all files with the ".dist" suffix
    unifrac_files <- list.files(pattern = ".*.dist")
    # Map over all files found
    dist_matrix <- map(unifrac_files, read_tsv)
    # Name them based on the file prefix
    names(dist_matrix) <- str_remove(unifrac_files, ".dist") %>%
      str_to_lower()
    ```

Using the above code block, we've read in 2 files and stored them as a list called `unifrac_dist`. In the list, there are 2 data frames, each containing a variation of the UniFrac distance matrix. 

??? tip "Export list elements to the Global environment `.GlobalEnv`"

    Sometimes you might want to export the imported data into the working environment (this is almost always the global environment `.GlobalEnv`). You can achieve this by doing the following:

    !!! r-project "code"

        ```r
        # Let's use the elements in unifrac_dist as an example
        list2env(unifrac_dist, envir = .GlobalEnv)
        # Print everything in the global environment
        ls()
        ```

        !!! success "Output"

            ```
            [1] "asv"                "meta"               "taxa"               "unifrac_dist"       "unifrac_files"     
            [6] "unweighted_unifrac" "weighted_unifrac"
            ```
        
    Take note that in order for this to work properly, you do need to name each element in the list.

**Appending a list**

In microbial ecology, it is also common to compare different kinds of distances and dissimilarities. Remember, we still have our explorer's hat on! Other commonly used dissimilarities are the Jaccard index (based on binary data) and Bray-Curtis dissimilarities (based on relative abundance data). These are calculated directly based on the `asv` data using `vegan`'s function called `vegdist()`. Let's also append this to our existing list of distance matrices.

```r
trad_dist_names <- c("jaccard", "bray") %>% 
  set_names(.)
trad_dist <- map(trad_dist_names, \(x) {
  # Transform the ASV table into a transposed numeric matrix
  data <- column_to_rownames(asv, "ASVID") %>% 
    t()
  # Convert matrix to presence-absence matrix for jaccard
  if (x == "jaccard") {
    data <- ifelse(data > 0, 1, 0)
  }
  # Calculate dissimilarities using the vector as arguments
  vegdist(data, method = x)
})

# Combine both lists
dist_matrix <- append(dist_matrix, trad_dist)
```

**Selectively modifying elements in a list**

Inspect your list after appending `trad_dist` into `dist_matrix`. We will do this using `purrr`'s set of functions that evaluate a predicate across a list. 

```r
every(dist_matrix, \(x) any(class(x) %in% "dist"))
```

```
[1] FALSE
```

Let's breakdown the function above:

* `every()` is a `purrr` function that checks that every element of the list (i.e., `dist_matrix`) returns a TRUE for the predicate function `\(x) any(class(x) %in% "dist"))`
* `any(class(x) %in% "dist"))` checks if any of the elements have the class attribute of "dist" (an object can have more than one class attribute). It returns a TRUE if any of them is a "dist", and FALSE if none of them are "dist"

!!! note "What is a predicate function?"

    These are functions that evaluate whether a statement (written in the form of a function) is TRUE or FALSE. This can be an anonymous function like those written above, or a named function such as `is.numeric()`. The function must output a single boolean value to be considered a predicate function. `purrr` offers other predicate functions (see cheat sheet) that may be useful depending on your needs.

Recall that when we read the UniFrac distances into our list, it was a data frame and tibble (due to the intrinsic nature of `read_tsv()`). We need to convert them into "dist" data types without modifying the other elements. We can do this using `modify_if()`:

```r
dist_matrix <- modify_if(
  dist_matrix, 
  \(x) !any(class(x) %in% "dist"), 
  \(x) {
    column_to_rownames(x, "sample") %>% 
      as.dist()
})
```

Oh my, two anonymous functions! Let's understand the anatomy of the `modify_if()`:

```r
modify_if(<vector/list>, <predicate function>, <function>)
```

Based on this, we can translate the above code block as:

> In the list `dist_matrix`, `modify_if()` the `class()` attribute of the element does not (`!`) contain `any()` characters `"dist"`. If the predicate returns a TRUE (i.e., it is not a distance matrix), then convert the `sample` column of the list element into the row names (and also remove it), and then convert the resulting `data.frame`/`tibble` into a `"dist"` object.


## Flexible tables using tibbles

Learning objectives:

* Understand the difference between tibbles and data frames
* Be able to create a tibble
* Be able to manipulate data to create nested data
* Store and manipulate lists within a tibble

## Activity: Exploring beta diversity


