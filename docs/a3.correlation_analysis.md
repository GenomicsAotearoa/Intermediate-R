# Exercise: Correlation analysis

Purpose of exercise: 

* Flexible approaches to a problem
* Simplify the solution by using vectorised-like code

Correlate relative abundance of prevalent ASVs with environmental variables.

## Prepare data

Filter `asv` and coerce to matrix.

!!! r-project "code"

    ```r linenums="1"
    asv_mt <- data.frame(asv, row.names = 1) %>% 
      as.matrix()

    asv_prv <- ifelse(asv_mt > 0, 1, 0) %>% 
      rowSums()

    prv_asvid <- names(asv_prv[asv_prv >= 0.5 * ncol(asv_mt)])

    prv_asv_mt <- asv_mt[rownames(asv_mt) %in% prv_asvid, ]
    ```

Prepare environmental data

!!! r-project "code"

    ```r linenums="1"
    env_mt <- data.frame(env, row.names = 1) %>% 
      as.matrix()
    ```

## Using a nested `for` loop

Prepare output

!!! r-project "code"

    ```r linenums="1"
    matrix_names <- list(
      rownames(prv_asv_mt),
      colnames(env_mt)
    )
    results <- list()

    for (x in c("rho", "p_value")) {
      results[[x]] <- matrix(
        nrow = nrow(prv_asv_mt), 
        ncol = ncol(env_mt), 
        dimnames = matrix_names
      )
    }
    ```

Calculate pairwise correlations

!!! r-project "code"

    ```r linenums="1"
    for (i in seq_along(1:nrow(prv_asv_mt))) {
    
      abd <- prv_asv_mt[i, ]
    
      for (j in seq_along(1:ncol(env_mt))) {

        env_var <- env_mt[, j]

        if (any(names(abd) != names(env_var))) {
        
          stop("Names do not match!")

        }

        correlation_test <- suppressWarnings(
          cor.test(abd, env_var, method = "spearman")
        )

        results$rho[i, j] <- correlation_test$estimate
        results$p_value[i, j] <- correlation_test$p.value

      }
    
    }
    ```

Get FDR adjust p-value

!!! note "Matrix to numeric vector"

    `p.adjust()` will coerce the input into a numeric atomic vector. Keep in mind that matrices unravel and are built by column unless `byrow = TRUE`.

!!! r-project "code"

    ```r linenums="1"
    results$p_adj <- matrix(
      p.adjust(results$p_value, method = "fdr"),
      nrow = nrow(results$p_value),
      ncol = ncol(results$p_value)
    )
    ```

## Using `map()` in a `tibble()`

Pivot and filter data

!!! r-project "code"

```r linenums="1"
asv_long <- pivot_longer(
  asv,
  cols = where(is.numeric),
  names_to = "sample",
  values_to = "abundance"
)

asv_prv_long <- asv_long %>% 
  mutate(
    presence = if_else(abundance > 0, 1, 0)
  ) %>% 
  group_by(ASVID) %>% 
  filter(
    sum(presence) >= 0.5 * 21
  )
```

Join and nest data

```r linenums="1"
asv_env_long <- left_join(asv_prv_long, env, by = "sample") %>% 
  pivot_longer(cols = mud.content:drp, names_to = "env_var", values_to = "env_value")

tibble_nest <- asv_env_long %>%
  select(-presence) %>% 
  nest(data = c(sample, abundance, env_value))
```

Iterate over rows to get values

```r linenums="1"
tibble_result <- tibble_nest %>% 
  ungroup() %>% 
  mutate(
    test = map(data, \(x) cor.test(x$abundance, x$env_value, method = "spearman")),
    rho = map_dbl(test, "estimate"),
    p_value = map_dbl(test, "p.value"),
    p_adj = p.adjust(p_value, method = "fdr")
  )
```

