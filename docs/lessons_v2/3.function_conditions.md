# Functions and conditional statements

!!! note "Learning objectives"

    * Write custom functions
    * Use conditional statements to control execution of code
    * Apply concepts in defensive programming to function writing

## I can make those?!

Functions are integral components of R. They are what make it possible to do, well, everything! Even addition `+` is a function: 

!!! r-project "code"

    ```r
    mode(`+`)
    str(`+`)
    ```

    > ```
    > [1] "function"
    > function (e1, e2)
    > ```

Like all things in R, a function is also an object (we'll see what other implications that has later). Think of functions as verbs. They are pieces of code that do something and produce an outcome (sometimes invisibly). Just as you can assign an object to a variable, you can assign entire chunks of code that "does something" to a object. In R, that is what a function is: an object that does something. So yes, you can write functions! 

In this lesson, we will write a custom function that calculates different alpha diversity metrics (a staple in any ecological analysis). We will also learn to construct conditional statements: code chunks that helps us handle decision making according to rules. Finally, we will learn a little bit about defensive programming and how that provides a practical foundation for writing resilient and reliable functions.

!!! info "How diverse is a sampled community?"
    
    This is likely the first question one asks when considering community ecology of any environment. A direct measure *diversity within a sample* (also known as *alpha diversity*) is richness (often denoted $q$ or $S$), which is the tally of number of species/taxonomic units present in any given sample. While simple and intuitive, it is heavily influenced by rare taxonomic units (as is often the case in microbiome samples). Therefore, other metrics which account for the *uneven distribution* of taxonomic units are also reported alongside richness. Popular options are:
    
    **Shannon's index, $\textrm{H}$**
    
    $$
    \large
    \textrm{H} = - \sum_{i=1}^{q} {p_i} \log {p_i}
    $$
    
    Where $p_i$ is the proportion of the $i$<sup>th</sup> organism relative to the sample total (also known as the relative frequency of the organism).
    
    **Inverse Simpson's concentration index, $D$**
    
    $$
    \large
    D = \frac{1}{\lambda}
    $$
    
    Where the concentration index $\lambda$ is defined as
    
    $$
    \large
    \lambda = \sum_{i=1}^{q} {p_i}^2
    $$

    If you are mathematically inclined, you might observe that these indices give more weight to abundant taxonomic units and that weighting is higher for $D$ than for $\textrm{H}$.

## Anatomy of a function

Here is a pseudocode representation of assigning a function:

```r
my_function <- function(<arguments>) {

  <do something>

}
```

All functions start with the `function` call, followed by arguments enveloped between parentheses, and finally the expression (the `<do something>` part of the pseudocode above). This defines what the function does. The expression need not be wrapped in curly brackets `{}` so long as it is on the same line as the `function` call. However, for long expressions, this makes code more legible such that the reader understands that the lines of code wrapped in `{...}` are part of the function object. Here is an example of a function that does $\sqrt{2(x + 1)}$:

!!! r-project "code"

    ```r
    f1 <- function(x) sqrt(2 * (x + 1))

    f1(x = 3)
    ```

    > ```
    > [1] 2.828427
    > ```

!!! tip "`function` shorthand"

    The `function` call can also be shortened to just a backslash `\` to mean the same thing. For example, this is equivalent to the code above:

    !!! r-project "code"

        ```r
        f1 <- \(x) sqrt(2 * (x + 1))
        ```
    
    This makes it easier to write short functions on the fly for interactive use.

**Default values**

Many pre-built functions that we use on a day-to-day basis takes one argument as user input. However, this is usually a convenience. For example:

!!! r-project "code"

    ```r
    log(5)
    ```

    > ```
    > [1] 1.609438
    > ```

By default, the `log()` function returns the natural log (base $e$). If we access its help page, we find that we can specify another base for the logarithm conversion.

!!! r-project "code"

    ```r
    log(5, base = 5)
    ```

    > ```
    > [1] 1
    > ```

To set default values for our custom functions, we need only place the value when configuring the arguments. The following function cubes `x` by default, but can take other values to exponentiate `x`.

!!! r-project "code"

    ```r
    f2 <- function(x, p = 3) x ^ p
    f2(3)
    f2(3, p = 5)
    ```

    > ```
    > [1] 27
    > [1] 243
    > ```

## Conditional execution

Before continuing on our journey to write functions, we need to take a brief look at conditional statements. These are common across all programming languages; you may know them as `if-else` statements. They are important constructs that control the flow of operations at all levels, be it within a function or a script, and even across scripts. In their most fundamental form, they resemble this:

```r
if (<predicate>) {

  <expression_1>

} else {

  <expression_2>

}
```

The code above means:

> If the predicate returns a TRUE, run code defined by `<expression_1>`, else run `<expression_2>`.

??? note "Predicate and predicate functions"

    A predicate is a statement or function that evaluation that returns **a single** `TRUE` or `FALSE`. For example, this is a predicate that evaluates if `x` is larger than 5:
    
    ```r
    x > 5
    ```

    If we set `x <- 10`, the code will return a `TRUE`.

    R has many built-in predicate functions (i.e., functions that evaluate a statement or object and returns a `TRUE`/`FALSE`) are often prefixed using `is.<something>()`. For example:

    !!! r-project "code"

        ```r
        x <- 9
        tim <- "Tim is eating"
        y <- 1:6

        # Predicate function
        is.character(x)
        is.character(tim)
        is.character(y)
        is.numeric(y)
        ```

        > ```
        > [1] FALSE
        > [1] TRUE
        > [1] FALSE
        > [1] TRUE
        > ```

    Notice that regardless of the length of the vector, the predicate functions return only one Boolean variable. This is important for conditional statements as it can only evaluate predicates and not a vector of Boolean variables.

To better illustrate what conditional statements do, lets construct an `if...else` to evaluate the following question:

Did we recruit enough reads to perform meaningful ecological analyses?

Lets say that a total read count of at least 500 is required for further analysis and that any value lower than or equal to 500 means we must remedy procedures in handling that sample. Here, our predicate is: `sum(<sample_column>) > 500`. 

!!! r-project "code"

    ```r
    reads_AS1A1 <- sum(asv$AS1A1)

    if (reads_AS1A1 > 500) {
      # If the predicate is TRUE, do this
      print(
        paste("This sample has", reads_AS1A1, "reads.")
      )
      print("It has sufficient reads.")

    } else {
      # If the predicate is FALSE, do this
      print("This sample has insufficient reads.")

    }
    ```

    > ```
    > [1] "This sample has 5610 reads."
    > [1] "It has sufficient reads."
    > ```

### Nested statements

If we had multiple predicates that needs to be chained one after another, we can construct nested conditional statements:

```r
if (<predicate>) {
  
  <expression_1>

} else if (<predicate>) {
  
  <expression_2>

} else {

  <expression_3>

}
```

For example:

!!! r-project "code"

    ```r
    reads_S3C3 <- sum(asv$S3C3)
    reads_S3C3

    if (reads_S3C3 > 5000) {
    
      print("Abundant reads")
    
    } else if (reads_S3C3 > 1000 & reads_S3C3 <= 5000) {
    
      print("High number of reads")
    
    } else if (reads_S3C3 > 500 & reads_S3C3 <= 1000) {
    
      print("Sufficient reads")
    
    } else {
    
      print("Insufficient reads")

    }
    ```

    > ```
    > [1] 870
    > [1] "Sufficient reads"
    > ```

When using nested statements, keep in mind that order matters. This means that if the first predicate is `TRUE`, none of the statements below it will be evaluated.

### Vectorised conditional statements

These are functions that 

1. Takes a vector of Boolean variables (or an expression that produces them)
2. Returns an outcome for each element if it is TRUE
3. Returns another outcome for each element if it FALSE

For binary decisions (i.e., `if (predicate) {...} else {...}`), there are two functions:

* `ifelse()`: part of base R
* `if_else()`: part of `dplyr`

They can both return short, simple variables:

!!! r-project "code"

    ```r
    read_sums <- colSums(asv[, -1])

    ifelse(
      read_sums > 5000, 
      "Sufficient reads", 
      "Insufficient reads"
    ) %>%
      tail()
    ```

    > ```
    >                  AS2C1                  AS2C2                  AS2C3                   S3C1 
    > "High number of reads" "High number of reads" "High number of reads" "High number of reads" 
    >                   S3C2                   S3C3 
    > "High number of reads"          "Check reads"
    > ```

or return values after evaluating longer expressions:

!!! r-project "code"

    ```r
    if_else(
      read_sums > 1000,
      {
        a <- sqrt(read_sums)
        paste("The square root of this is", a)
      },
      {
        a <- read_sums ^ (1/3)
        paste("The cube root of this is", a)
      }
    ) %>%
      tail()
    ```

    > ```
    >                                         AS2C1                                         AS2C2 
    > "The square root of this is 78.4283112147648" "The square root of this is 75.6174583016383" 
    >                                         AS2C3                                          S3C1 
    > "The square root of this is 82.4075239283404" "The square root of this is 33.5111921602321" 
    >                                          S3C2                                          S3C3 
    > "The square root of this is 60.5061980296234"   "The cube root of this is 9.54640270936004"
    > ```

For nested statements, there is `case_when()` from `dplyr` that takes the form of:

```r
case_when(
  <predicate_1> ~ <expression_1>,
  <predicate_2> ~ <expression_2>,
  <predicate_3> ~ <expression_3>,
  ...
  TRUE ~ <default_value>
)
```

### Practical usage

**`else` is optional**

For most use cases, it is sufficient (and less redundant) to only construct the `if (<predicate>) {<expression>}` part of the statement. Unless there is a good reason to pick one option over the other, the `else {<expression>}` is optional and can be entirely omitted. This is because R will only execute the expression within the statement if the predicate is `TRUE`. For this reason, it is very common to see the `else {}` omitted in functions.

**Nested statements are rarely a good idea**

Often, nested statements (and it vectorised function) are not helpful. In the best of cases, you may have a reason to use them. For example, there may be genuine need for a hierarchical way of evaluating the flow of data where some collection of thresholds warrant a different method of processing data downstream. However, this can lead to messy code that ends up being illegible and the results can be cryptic if one is not on top of things (i.e., the reader may not intuitively know where the results come from based on the chain of statements). 

It is better to break up the expression and set them as different functions called under different scenarios. This modular structure means that you not only remove potential redundancies, but it also improves code legibility where readers can easily determine the functions that are being called, the expression the function uses, and the intended result.

**Vectorise for one-off use cases**

R is particularly proficient when we use functions that take in vectors. In cases where you need to `mutate()` a column in a data frame (e.g., replacing values based on pattern searches and return a variable), the vectorised `if_else()` and `case_when()` are your friends. Also, I prefer to use `if_else()` as opposed to `ifelse()` as it can handle missing values and produce consistent output types, a coveted feature in ensuring input-output consistency.

## Code in action: A function for $\alpha$-diversity

















