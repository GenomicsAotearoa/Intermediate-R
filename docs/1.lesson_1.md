# Set up

Load libraries and import data.

!!! r-project "code"

    ```r
    library(readr)
    library(dplyr)
    library(stringr)
    
    asv <- read_tsv("tables/asv_table.tsv")
    taxa <- read_tsv("tables/taxonomy.tsv")
    env_data <- read_tsv("tables/env_table.tsv")
    ```

## Activity aims

* Create a taxonomy bar plot of relative abundances at Proteobacterial class level and phylum level for other phyla

# Conditional statements

Learning objectives:

* Understand the `if...else` construct
* Understand that conditions can be chained sequentially

The anatomy of the `if..else`:

```
if (expression) {

  do_something()

} else {

  do_something_else()

}
```

The `if...else` construct is a way of controlling output depending on a condition as evaluated using the expression inside the `(...)`. In other words, if the expression returns a `TRUE`, it will run the code within the first `{...}`, otherwise, it will run code in the second chunk `{...}`.

!!! r-project "code"

    ```r
    # Obtain total number of reads for a sample
    num_reads <- sum(asv$AS1A1)

    # Print output if the number of reads exceed 1000
    if (num_reads > 1000) {
      print("Exceeds 1000 reads")
    } else {
      print("Below 1000 reads")
    }
    ```

    !!! success "Output"

        ```
        [1] "Exceeds 1000 reads"
        ```

You can also omit the `else` part if you only want to do something if the condition is `TRUE`. The following statement will provide an output.

!!! r-project "code"

    ```r
    if (num_reads > 1000) {
      print("Exceeds 1000 reads")
    }
    ```

    !!! success "Output"

        ```
        [1] "Exceeds 1000 reads"
        ```

However, this one will not.

!!! r-project "code"

    ```r
    if (num_reads < 1000) {
      print("Below 1000 reads")
    }
    ```

You can also chain multiple conditions together to generate different outputs depending on the results of each evaluated condition.

!!! r-project "code"

    ```r
    num_reads <- sum(asv$AS1A2)

    if (num_reads > 5000) {
      print("High biomass")
    } else if (num_reads >= 1000 & num_reads < 5000) {
      print("Adequate biomass")
    } else if (num_reads < 1000) {
      print("Inadequate biomass")
    } else {
      print("Unknown")
    }
    ```

    !!! success "Output"

        ```
        [1] "Adequate biomass"
        ```

When chaining multiple conditions, be aware of the order of the conditions. This is because conditions are evaluated sequentially. For example:

!!! r-project "code"

    ```r
    if (num_reads > 1000) {
      print("Exceeds 1000 reads")
    } else if (num_reads >= 1000 & num_reads < 5000) {
      print("Adequate biomass")
    } else {
      print("Unknown")
    }
    ```

    !!! success "Output"

        ```
        [1] "Exceeds 1000 reads"
        ```

Note that both the first and second expressions are `TRUE`, but only the first code chunk ran. This can become important if you need to run different code depending on value ranges. Here, the priority of conditions is paramount to how you need to construct your `if...else` statements.

# String manipulation

Learning objectives:

* Detect patterns in strings
* Subset strings based on pattern
* Extract substrings based on pattern
* Replace substrings based on pattern
* Be aware of convenience functions

Knowing how to detect, subset, and replace strings is helpful for quick checks and at later stages when you need to plot your data. The `Taxon` column in the `taxa` data frame is a helpful example for learning how to manipulate strings. This column consists of taxonomy assigned to each ASV (or feature). Glance at it using RStudio's viewer, you may notice that ASVs can be assigned taxonomy at any level (i.e., some ASVs are identified up to species level, some are identified only up to domain level). Let's start with detecting strings.

!!! r-project "code"

    ```r
    # Count number ASVs assigned as Archaea
    sum(str_detect(string = taxa$Taxon, pattern = "Archaea"))
    ```

    !!! success "Output"

        ```
        [1] 33
        ```

In the code above, `str_detect()` returns a logical vector, and `sum()` counts the number of `TRUE` elements. Now that we know we have 33 Archaeal ASVs, we might be interested in their lineage.

!!! r-project "code"

    ```r
    archaea_lineage <- str_subset(string = taxa$Taxon, pattern = "Archaea")

    # Get de-duplicated lineages
    unique(archaea_lineage)
    ```

    !!! success "Output"

        ```
        [1] "d__Archaea;_p__Crenarchaeota; c__Nitrososphaeria; o__Nitrosopumilales; f__Nitrosopumilaceae; g__Candidatus_Nitrosopumilus"                              
        [2] "d__Archaea;_p__Crenarchaeota; c__Nitrososphaeria; o__Nitrosopumilales; f__Nitrosopumilaceae; g__Candidatus_Nitrosopelagicus; s__uncultured_archaeon"    
        [3] "d__Archaea;_p__Crenarchaeota; c__Nitrososphaeria; o__Nitrosopumilales; f__Nitrosopumilaceae; g__Nitrosopumilaceae"                                      
        [4] "d__Archaea;_p__Crenarchaeota; c__Bathyarchaeia; o__Bathyarchaeia; f__Bathyarchaeia; g__Bathyarchaeia; s__uncultured_miscellaneous"                      
        [5] "d__Archaea;_p__Crenarchaeota; c__Nitrososphaeria; o__Nitrosopumilales; f__Nitrosopumilaceae; g__Candidatus_Nitrosopumilus; s__Candidatus_Nitrosopumilus"
        [6] "d__Archaea;_p__Crenarchaeota; c__Bathyarchaeia; o__Bathyarchaeia; f__Bathyarchaeia; g__Bathyarchaeia"
        ```

Using `unique()`, we see that we have Archaeal representatives that are all part of the phylum Crenarchaeota and class Nitrososphaeria and Bathyarchaeia.

We can also extract part of a string. Here is an example where we extract "Nitrososphaeria" from the `archaea_lineage`.

# Joins

Learning objectives:

* Understand the use of different `join_*()`
* Use join to combine tables based on different columns

# Loops for iteration

Learning objectives:

* Understand the `for` construct
* Understand the difference between iterating vectors directly or their indices


