# Functions and loops

## Functions

Learning objectives:

* Understand the anatomy of a function
* Be able to write a function
* Write functions that have predictable outputs
 
Think of functions as verbs. They do something to your data and generates some output. In your R journey, you have been using pre-coded functions. Here, we will write our own functions to perform some task. All functions have the following structure:

```r
do_something <- function(x, y) {
  # ...doing something with x and y...
  # Addition of x and y
  x + y
}
```

In the pseudo-code above, we have a function *named* `do_something` that takes *arguments* `x` and `y` and then a *body* enveloped by `{...}` that has code performing an addition between the arguments.

### Understanding functions by writing one

A cornerstone concept in ecology is species diversity. This pertains to how organisms are distributed across space. Simplified in the form of a question: "How diverse is a sample?" The most direct measure of diversity is richness (often denoted using the letter $q$). This is essentially the number of organisms present in a sample. For any sample (remember, these are columns) in our ASV table, we can obtain richness by counting the number of non-zero elements in the column vector:

!!! r-project "code"

    ```r
    # The species richness of sample AS1A1
    sum(asv$AS1A1 > 0)
    ```

    !!! success "Output"

        ```
        [1] 1221
        ```

For a simple measure of richness, you can probably do this manually via copy-paste for multiple sample:

!!! r-project "code"

    ```r
    sum(asv$AS1A2 > 0)
    sum(asv$AS1A3 > 0)
    sum(asv$AS1B1 > 0)
    sum(asv$AS1B2 > 0)
    # etc...
    sum(asv$S3C3 > 0)
    ```

    !!! success "Output"

        ```
        [1] 744
        [1] 1149
        [1] 1169
        [1] 1161
        [1] 305
        ```

One drawback with richness is that the measure gives equal weight to abundant and rare organisms. Another measure of sample diversity is the Shannon index (denoted with the Greek uppercase eta $\eta$, $\textrm{H}$ as it was originally conceived as a measure of information **entropy**). This is calculated using the following formula:

$$\textrm{H} = - \sum_{i=1}^{q} {p_i} \log {p_i}$$

where $p_i$ is the proportion of the $i$<sup>th</sup> organism relative to the sample total (also known as the relative frequency of the organism).

$$p_i = \frac{x_i}{\sum_{i=1}^{q} x_i}$$

If you were to calculate the Shannon's index for a sample, if would look like this:

!!! r-project "code"

    ```r
    # Calculate the relative frequency of each ASV
    p_AS1A1 <- asv$AS1A1 / sum(asv$AS1A1)
    # Calculate the multiplication between relative frequencies and its log
    pp_AS1A1 <- - p_AS1A1 * log(p_AS1A1)
    # Calculate the Shannon's index
    sum(pp_AS1A1, na.rm = TRUE)
    # Note that you will need na.rm = TRUE as there are zeroes in the vector and the logarithm of zero is NaN (it is not mathematically defined)
    ```

    !!! success "Output"

        ```
        [1] 6.651707
        ```

Technically, we could condense the above code into a single chunk:

!!! r-project "code"

    ```r
    sum(- (asv$AS1A1 / sum(asv$AS1A1)) * log((asv$AS1A1 / sum(asv$AS1A1))), na.rm = TRUE)
    ```

This will still work, but it is difficult to read. The equation for Shannon's index is simple enough that this is still decipherable. But it can quickly become unruly if equations are more complicated or have dependencies on other pre-calculated values. Moreover, this is not easily reusable. This is when turning equations or any multi-step calculations into functions really shine.

We can turn the 3-step calculations into a function to obtain one value, like so:

!!! r-project "code"

    ```r
    diversity_index <- function(abundance) {
      # Calculate relative frequency
      p_i <- abundance / sum(abundance)
      # Calculate multiplication between relative frequencies and its log
      pp_i <- p_i * log(p_i)
      # Calculate Shannon's index
      - sum(pp_i, na.rm = TRUE) 
    }
    ```

Here, we have written a function that calculates the index and provided it with an informative name. Lets try it out and see if we get the same output:

!!! r-project "code"

    ```r
    diversity_index(abundance = asv$AS1A1)
    ```

    !!! success "Output"

        ```
        [1] 6.651707
        ```

### Conditional statements inside functions

What if we wanted to evaluate different diversity indices? We can create conditional statements within the functions to take in arguments. For this example, we will also add another diversity index, the Simpson's concentration index ($\lambda$), which shares some similarities with Shannon's index.

$$\lambda = \sum_{i=1}^{q} {p_i}^2$$

However, unlike Shannon's index, the property of Simpson's concentration index is such that tha larger the value of $\lambda$, the less evenly distributed the organisms in the sample. Hence the name "concentration index", where the larger the value, the more concentrated the distribution of the community members. To make the relationship between diversity and value magnitude the same between indices, Simpson's diversity index is usually denoted as $\textrm{D} = 1 - \lambda$ or $\textrm{D} = \frac{1}{\lambda}$. We can account for that in our function argument as well.

!!! r-project "code"

    ```r
    diversity_index <- function(abundance, index = "shannon", log.base = exp(1)) {
      
      # Calculate richness
      if (index == "richness") {
        result <- sum(abundance > 0)
      }

      # As both Shannon's and Simpson's concentration indices require p_i,
      # calculate that first
      p_i <- abundance / sum(abundance)
      
      # Calculate Shannon's index
      if (index == "shannon") {
        pp_i <- p_i * log(p_i, base = log.base)
        result <- - sum(pp_i, na.rm = TRUE)
      }

      # Calculate Simpson's diversity index
      if (index == "simpson") {
        pp_i <- p_i ^ 2
        result <- 1 - sum(pp_i)
      }

      if (index == "invsimpson") {
        pp_i <- p_i ^ 2
        result <- 1 - sum(pp_i)
      }

      # Generate final result
      result

    }
    ```

In the function above, we have modified the function to take 3 arguments:

* `abundance`: A numeric vector of counts
* `index`: The diversity index desired
* `log.base`: The base for the logarithm calculation for Shannon's index

Notice that for `index` and `log.base`, we pre-populate the function arguments with values `"shannon"` and `exp(1)`. This means that those are default values for the function. If you were to directly call the function without supplying anything other than `abundance`, it would return Shannon's index calculated in the scale of the natural log. If we wanted to calculate the Shannon's index with a different log base, we simply add our own value to the `log.base` argument.

!!! r-project "code"

    ```r
    diversity_index(abundance = asv$AS1A1, log.base = 2)
    ```

    !!! success "Output"

        ```
        [1] 9.596384
        ```

If we wanted to get Simpson's concentration index:

!!! r-project "code"

    ```r
    diversity_index(abundance = asv$AS1A1, index = "simpson")
    ```

    !!! success "Output"

        ```
        [1] 0.9972477
        ```

### Things that might go wrong

At this point, we have written a function `diversity_index()` that calculates 3 different indices and can adjust for different choices of log bases. However, there are some weaknesses to our function. Have a think before moving forward what they might be.

??? tip "Weak points of `diversity_index`"

    * `NA` handling only for Shannon's index as is required (log of 0 is undefined) but not others (What if input vector contains missing values?)
    * Redundancy in calculating `pp_i` for derivatives of Simpson's index (`pp_i` is the same regardless of calculating Simpson's diversity or it's inverse)
    * No explicit way of knowing correct argument values without looking at code (Will you remember what the arguments are 12 months from now?)
    * No error handling of inappropriate types of data or negative values (`index = "shannon"` might provide useful error messages, but other indices will provide an output as normal)

To mitigate some of the potential issues, we might want to restrict how our function evaluates and processes input, as well as have the function provide useful error messages in case of problems. Here, two base R functions are useful:

* `stop()` creates an error message and stops the execution of the following lines of code in the body.
* `match.arg()` allows for partial matching of argument values and also produces a helpful error message on what are appropriate values if there is a typo.
* `switch()` allows for different evaluations depending on the argument without chaining multiple if...else statements to make code more readable.

!!! r-project "code"

    ```r
    diversity_index <- function(abundance, index = "shannon", log.base = exp(1)) {
      # Ensure abundance is a vector of positive numeric values
      if (!is.numeric(abundance) || any(abundance < 0, na.rm = TRUE)) {
        stop("Abundance data must be numeric and positive!")
      }

      # Check if missing values are to be ignored
      if (any(is.na(abundance))) {
        cat("Input contains missing values, returning NA.\n")
        return(NA)
      }

      # Match arguments to appropriate index
      indices <- c("richness", "shannon", "simpson", "invsimpson")
      index <- match.arg(index, indices)

      # Pre-calculate p_i and pp_i
      p_i <- abundance / sum(abundance)

      if (isTRUE(str_detect(index, "simpson"))) {
        # Simpson's
        pp_i <- p_i ^ 2
      } else {
        # Shannon's
        pp_i <- - p_i * log(p_i, base = log.base)
      }

      H <- sum(pp_i, na.rm = TRUE)

      # Final output
      result <- switch(
        index,
        shannon = H,
        richness = sum(abundance > 0),
        invsimpson = 1 / H,
        simpson = 1 - H
      )

      result

    }
    ```

Now, let's try the new function under various scenarios. Using sample S3C1 as an example, we will test if it properly handles the following scenarios:

* Handles missing values depending on `na.rm` arguments
* Checks input data type
* Checks input data range

!!! r-project "code"

    ```r
    # Extract column S3C1 as a test vector and sort it for convenience
    test_vector <- sort(asv$S3C1, decreasing = TRUE)
    # Introduce NA into test vector
    test_missing <- test_vector
    test_missing[c(6, 8, 12)] <- NA
    # Introduce negative values into test vector
    test_negative <- test_vector
    test_negative[c(6, 8, 12)] <- -test_vector[c(6, 8, 12)]
    # Add characters into test vector
    test_char <- test_vector
    test_char[c(6, 8, 12)] <- as.character(test_char[c(6, 8, 12)]) 

    # Test our modified function to calculate the inverse Simpson's diversity
    diversity_index(test_vector, index = 'inv')
    diversity_index(test_missing, index = 'inv')
    diversity_index(test_negative, index = 'inv')
    diversity_index(test_char, index = 'inv')
    ```

    !!! success "Output"

        ```
        [1] 236.654

        Input contains missing values, returning NA.
        [1] NA

        Error in diversity_index(test_negative, index = "inv") : 
          Abundance data must be numeric and positive!

        Error in diversity_index(test_char, index = "inv") : 
          Abundance data must be numeric and positive!
        ```

!!! tip "Checking results of `diversity_index()`"

    In the package `vegan`, there is a function that is equivalent to `diversity_index()` called `diversity()`. You can check if the results of `diversity_index()` is the same as that produced by `vegan::diversity()`.

!!! tip "Improve function writing"

    Writing good functions is an art in itself. I find it helpful to model how I write functions by reading and studying the source code of pre-coded functions in R packages. By reading other people's code, I also learn other helpful functions that were previously unknown to me or ways to deploy familiar functions that may help me solve problems in other areas. 
    
    In RStudio, you can lookup the source code for most functions using `View(<function_name>)`. For example, here is a snapshot of the source code for the function `diversity()` from the `vegan` package:

    !!! r-project "code"

        ```r
        View(vegan::diversity)
        ```

        ??? success "Output"

            ```r
            function (x, index = "shannon", groups, equalize.groups = FALSE, 
              MARGIN = 1, base = exp(1)) 
            {
              x <- drop(as.matrix(x))
              if (!is.numeric(x)) 
                stop("input data must be numeric")
              if (any(x < 0, na.rm = TRUE)) 
                stop("input data must be non-negative")
              if (!missing(groups)) {
                if (MARGIN == 2) 
                  x <- t(x)
                if (length(groups) == 1) 
                  groups <- rep(groups, NROW(x))
                if (equalize.groups) 
                  x <- decostand(x, "total")
                x <- aggregate(x, list(groups), sum)
                rownames(x) <- x[, 1]
                x <- x[, -1, drop = FALSE]
                if (MARGIN == 2) 
                  x <- t(x)
              }
              INDICES <- c("shannon", "simpson", "invsimpson")
              index <- match.arg(index, INDICES)
              if (length(dim(x)) > 1) {
                total <- apply(x, MARGIN, sum)
                x <- sweep(x, MARGIN, total, "/")
              }
              else {
                x <- x/(total <- sum(x))
              }
              if (index == "shannon") 
                x <- -x * log(x, base)
              else x <- x * x
              if (length(dim(x)) > 1) 
                H <- apply(x, MARGIN, sum, na.rm = TRUE)
              else H <- sum(x, na.rm = TRUE)
              if (index == "simpson") 
                H <- 1 - H
              else if (index == "invsimpson") 
                H <- 1/H
              if (any(NAS <- is.na(total))) 
                H[NAS] <- NA
              H
            }
            ```
      
      For functions that are coded in other methods, here is an immensely helpful [page on stackoverflow](https://stackoverflow.com/questions/19226816/how-can-i-view-the-source-code-for-a-function) that illustrates multiple ways of obtaining function source codes.


## Iteration using loops

Learning objectives:

* Understand the `for` construct
* Understand the difference between iterating vectors directly or their indices
* Be able to assign results of an iteration to object
* Understand nested functions

In the previous section, we have written a function that takes a numeric vector input and produces a single numeric or `NA` output. Copy-pasting and changing input variables is okay for a few inputs, but there are 21 samples in our ASV table! Thankfully, 
