# Functions and loops

## Functions

Learning objectives:

* Understand the anatomy of a function
* Be able to write a function
* Write functions that have predictable outputs
 
Think of functions as verbs. They do something to your data and generates some output. In your R journey, you have been using pre-coded functions. Here, we will write our own functions to perform some task. All functions have the following structure:

```r
do_something <- function(x, y) {
  # ...doing something with x and y...
  # Addition of x and y
  x + y
}
```

In the pseudo-code above, we have a function *named* `do_something` that takes *arguments* `x` and `y` and then a *body* enveloped by `{...}` that has code performing an addition between the arguments.

### Understanding functions by writing one

A cornerstone concept in ecology is species diversity. This pertains to how organisms are distributed across space. Simplified in the form of a question: "How diverse is a sample?" The most direct measure of diversity is richness (often denoted using the letter $q$). This is essentially the number of organisms present in a sample. For any sample (remember, these are columns) in our ASV table, we can obtain richness by counting the number of non-zero elements in the column vector:

!!! r-project "code"

    ```r
    # The species richness of sample AS1A1
    sum(asv$AS1A1 > 0)
    ```

    !!! success "Output"

        ```
        [1] 1221
        ```

For a simple measure of richness, you can probably do this manually via copy-paste for multiple sample:

!!! r-project "code"

    ```r
    sum(asv$AS1A2 > 0)
    sum(asv$AS1A3 > 0)
    sum(asv$AS1B1 > 0)
    sum(asv$AS1B2 > 0)
    # etc...
    sum(asv$S3C3 > 0)
    ```

    !!! success "Output"

        ```
        [1] 744
        [1] 1149
        [1] 1169
        [1] 1161
        [1] 305
        ```

One drawback with richness is that the measure gives equal weight to abundant and rare organisms. Another measure of sample diversity is the Shannon index (denoted with the Greek uppercase eta $\eta$, $\textrm{H}$ as it was originally conceived as a measure of information **entropy**). This is calculated using the following formula:

$$\textrm{H} = - \sum_{i=1}^{q} {p_i} \log {p_i}$$

where $p_i$ is the proportion of the $i$<sup>th</sup> organism relative to the sample total (also known as the relative frequency of the organism).

$$p_i = \frac{x_i}{\sum_{i=1}^{q} x_i}$$

If you were to calculate the Shannon's index for a sample, if would look like this:

!!! r-project "code"

    ```r
    # Calculate the relative frequency of each ASV
    p_AS1A1 <- asv$AS1A1 / sum(asv$AS1A1)
    # Calculate the multiplication between relative frequencies and its log
    pp_AS1A1 <- - p_AS1A1 * log(p_AS1A1)
    # Calculate the Shannon's index
    sum(pp_AS1A1, na.rm = TRUE)
    # Note that you will need na.rm = TRUE as there are zeroes in the vector and the logarithm of zero is NaN (it is not mathematically defined)
    ```

    !!! success "Output"

        ```
        [1] 6.651707
        ```

Technically, we could condense the above code into a single chunk:

!!! r-project "code"

    ```r
    sum(- (asv$AS1A1 / sum(asv$AS1A1)) * log((asv$AS1A1 / sum(asv$AS1A1))), na.rm = TRUE)
    ```

This will still work, but it is difficult to read. The equation for Shannon's index is simple enough that this is still decipherable. But it can quickly become unruly if equations are more complicated or have dependencies on other pre-calculated values. Moreover, this is not easily reusable. This is when turning equations or any multi-step calculations into functions really shine.

We can turn the 3-step calculations into a function to obtain one value, like so:

!!! r-project "code"

    ```r
    diversity_index <- function(abundance) {
      # Calculate relative frequency
      p_i <- abundance / sum(abundance)
      # Calculate multiplication between relative frequencies and its log
      pp_i <- p_i * log(p_i)
      # Calculate Shannon's index
      - sum(pp_i, na.rm = TRUE) 
    }
    ```

Here, we have written a function that calculates the index and provided it with an informative name. Lets try it out and see if we get the same output:

!!! r-project "code"

    ```r
    diversity_index(abundance = asv$AS1A1)
    ```

    !!! success "Output"

        ```
        [1] 6.651707
        ```

### Conditional statements inside functions

What if we wanted to evaluate different diversity indices? We can create conditional statements within the functions to take in arguments. For this example, we will also add another diversity index, the Simpson's concentration index ($\lambda$), which shares some similarities with Shannon's index.

$$\lambda = \sum_{i=1}^{q} {p_i}^2$$

However, unlike Shannon's index, the property of Simpson's concentration index is such that tha larger the value of $\lambda$, the less evenly distributed the organisms in the sample. Hence the name "concentration index", where the larger the value, the more concentrated the distribution of the community members. To make the relationship between diversity and value magnitude the same between indices, Simpson's diversity index is usually denoted as $\textrm{D} = 1 - \lambda$ or $\textrm{D} = \frac{1}{\lambda}$. We can account for that in our function argument as well.

!!! r-project "code"

    ```r
    diversity_index <- function(abundance, index = "shannon", log.base = exp(1)) {
      
      # Calculate richness
      if (index == "richness") {
        result <- sum(abundance > 0)
      }

      # As both Shannon's and Simpson's concentration indices require p_i,
      # calculate that first
      p_i <- abundance / sum(abundance)
      
      # Calculate Shannon's index
      if (index == "shannon") {
        pp_i <- p_i * log(p_i, base = log.base)
        result <- - sum(pp_i, na.rm = TRUE)
      }

      # Calculate Simpson's diversity index
      if (index == "simpson") {
        pp_i <- p_i ^ 2
        result <- 1 - sum(pp_i)
      }

      if (index == "invsimpson") {
        pp_i <- p_i ^ 2
        result <- 1 - sum(pp_i)
      }

      # Generate final result
      result

    }
    ```

In the function above, we have modified the function to take 3 arguments:

* `abundance`: A numeric vector of counts
* `index`: The diversity index desired
* `log.base`: The base for the logarithm calculation for Shannon's index

Notice that for `index` and `log.base`, we pre-populate the function arguments with values `"shannon"` and `exp(1)`. This means that those are default values for the function. If you were to directly call the function without supplying anything other than `abundance`, it would return Shannon's index calculated in the scale of the natural log. If we wanted to calculate the Shannon's index with a different log base, we simply add our own value to the `log.base` argument.

!!! r-project "code"

    ```r
    diversity_index(abundance = asv$AS1A1, log.base = 2)
    ```

    !!! success "Output"

        ```
        [1] 9.596384
        ```

If we wanted to get Simpson's concentration index:

!!! r-project "code"

    ```r
    diversity_index(abundance = asv$AS1A1, index = "simpson")
    ```

    !!! success "Output"

        ```
        [1] 0.9972477
        ```

### Things that might go wrong

At this point, we have written a function `diversity_index()` that calculates 3 different indices and can adjust for different choices of log bases. However, there are some weaknesses to our function. Have a think before moving forward what they might be.

??? tip "Weak points of `diversity_index`"

    * `NA` handling only for Shannon's index as is required (log of 0 is undefined) but not others (What if input vector contains missing values?)
    * Redundancy in calculating `pp_i` for derivatives of Simpson's index (`pp_i` is the same regardless of calculating Simpson's diversity or it's inverse)
    * No explicit way of knowing correct argument values without looking at code (Will you remember what the arguments are 12 months from now?)
    * No error handling of inappropriate types of data or negative values (`index = "shannon"` might provide useful error messages, but other indices will provide an output as normal)

To mitigate some of the potential issues, we might want to restrict how our function evaluates and processes input, as well as have the function provide useful error messages in case of problems. Here, two base R functions are useful:

* `stop()` creates an error message and stops the execution of the following lines of code in the body.
* `match.arg()` allows for partial matching of argument values and also produces a helpful error message on what are appropriate values if there is a typo.
* `switch()` allows for different evaluations depending on the argument without chaining multiple if...else statements to make code more readable.

!!! r-project "code"

    ```r
    diversity_index <- function(abundance, index = "shannon", log.base = exp(1)) {
      # Ensure abundance is a vector of positive numeric values
      if (!is.numeric(abundance) || any(abundance < 0, na.rm = TRUE)) {
        stop("Abundance data must be numeric and positive!")
      }

      # Check if missing values are to be ignored
      if (any(is.na(abundance))) {
        cat("Input contains missing values, returning NA.\n")
        return(NA)
      }

      # Match arguments to appropriate index
      indices <- c("richness", "shannon", "simpson", "invsimpson")
      index <- match.arg(index, indices)

      # Pre-calculate p_i and pp_i
      p_i <- abundance / sum(abundance)

      if (isTRUE(str_detect(index, "simpson"))) {
        # Simpson's
        pp_i <- p_i ^ 2
      } else {
        # Shannon's
        pp_i <- - p_i * log(p_i, base = log.base)
      }

      H <- sum(pp_i, na.rm = TRUE)

      # Final output
      result <- switch(
        index,
        shannon = H,
        richness = sum(abundance > 0),
        invsimpson = 1 / H,
        simpson = 1 - H
      )

      result

    }
    ```

Now, let's try the new function under various scenarios. Using sample S3C1 as an example, we will test if it properly handles the following scenarios:

* Handles missing values depending on `na.rm` arguments
* Checks input data type
* Checks input data range

!!! r-project "code"

    ```r
    # Extract column S3C1 as a test vector and sort it for convenience
    test_vector <- sort(asv$S3C1, decreasing = TRUE)
    # Introduce NA into test vector
    test_missing <- test_vector
    test_missing[c(6, 8, 12)] <- NA
    # Introduce negative values into test vector
    test_negative <- test_vector
    test_negative[c(6, 8, 12)] <- -test_vector[c(6, 8, 12)]
    # Add characters into test vector
    test_char <- test_vector
    test_char[c(6, 8, 12)] <- as.character(test_char[c(6, 8, 12)]) 

    # Test our modified function to calculate the inverse Simpson's diversity
    diversity_index(test_vector, index = 'inv')
    diversity_index(test_missing, index = 'inv')
    diversity_index(test_negative, index = 'inv')
    diversity_index(test_char, index = 'inv')
    ```

    !!! success "Output"

        ```
        [1] 236.654

        Input contains missing values, returning NA.
        [1] NA

        Error in diversity_index(test_negative, index = "inv") : 
          Abundance data must be numeric and positive!

        Error in diversity_index(test_char, index = "inv") : 
          Abundance data must be numeric and positive!
        ```

!!! tip "Checking results of `diversity_index()`"

    In the package `vegan`, there is a function that is equivalent to `diversity_index()` called `diversity()`. You can check if the results of `diversity_index()` is the same as that produced by `vegan::diversity()`.

!!! tip "Improve function writing"

    Writing good functions is an art in itself. I find it helpful to model how I write functions by reading and studying the source code of pre-coded functions in R packages. By reading other people's code, I also learn other helpful functions that were previously unknown to me or ways to deploy familiar functions that may help me solve problems in other areas. 
    
    In RStudio, you can lookup the source code for most functions using `View(<function_name>)`. For example, here is a snapshot of the source code for the function `diversity()` from the `vegan` package:

    !!! r-project "code"

        ```r
        View(vegan::diversity)
        ```

        ??? success "Output"

            ```r
            function (x, index = "shannon", groups, equalize.groups = FALSE, 
              MARGIN = 1, base = exp(1)) 
            {
              x <- drop(as.matrix(x))
              if (!is.numeric(x)) 
                stop("input data must be numeric")
              if (any(x < 0, na.rm = TRUE)) 
                stop("input data must be non-negative")
              if (!missing(groups)) {
                if (MARGIN == 2) 
                  x <- t(x)
                if (length(groups) == 1) 
                  groups <- rep(groups, NROW(x))
                if (equalize.groups) 
                  x <- decostand(x, "total")
                x <- aggregate(x, list(groups), sum)
                rownames(x) <- x[, 1]
                x <- x[, -1, drop = FALSE]
                if (MARGIN == 2) 
                  x <- t(x)
              }
              INDICES <- c("shannon", "simpson", "invsimpson")
              index <- match.arg(index, INDICES)
              if (length(dim(x)) > 1) {
                total <- apply(x, MARGIN, sum)
                x <- sweep(x, MARGIN, total, "/")
              }
              else {
                x <- x/(total <- sum(x))
              }
              if (index == "shannon") 
                x <- -x * log(x, base)
              else x <- x * x
              if (length(dim(x)) > 1) 
                H <- apply(x, MARGIN, sum, na.rm = TRUE)
              else H <- sum(x, na.rm = TRUE)
              if (index == "simpson") 
                H <- 1 - H
              else if (index == "invsimpson") 
                H <- 1/H
              if (any(NAS <- is.na(total))) 
                H[NAS] <- NA
              H
            }
            ```
      
      For functions that are coded in other methods, here is an immensely helpful [page on stackoverflow](https://stackoverflow.com/questions/19226816/how-can-i-view-the-source-code-for-a-function) that illustrates multiple ways of obtaining function source codes.


## Iteration using loops

Learning objectives:

* Understand the `for` construct
* Be able to assign results of an iteration to object
* Understand different kinds of iterations
* Understand nested loops

### The anatomy of a loop

In the previous section, we have written a function that takes a numeric vector input and produces a single numeric or `NA` output. Copy-pasting and changing input variables is okay for a few inputs, but there are 21 samples in our ASV table! Thankfully, computers are very good at doing the same things multiple times, quickly. This is known as iteration. The basic form of iteration in R (and most other programming languages) is a `for` loop. We will look at the anatomy of a `for` loop in R using an example:

```r
loop_output <- vector(mode = "character", length = ncol(asv)) # Output

for (i in seq_along(asv)) {                                   # Sequence
  
  loop_output[i] <- typeof(asv[[i]])                          # Body
  names(loop_output)[i] <- names(asv)[i]                      # Body

}
```

Let's dissect what is going on in the code above:

1. We create an empty output vector `loop_output` using `vector()` with the same length as the number of columns as the ASV table. 
2. `for (i in seq_along(asv))` represents the sequence by which to loop over. Here, `seq_along(asv)` generates a numeric vector that starts from `1`, ends at the number of columns of `asv` with an increment of `1`. Therefore, this line means "for every number (`i`) from 1 to the number of columns in `asv`, do `{...}`". 
3. Like the `if...else` evaluations, anything within the body of `{...}` represents code to execute. This is the body that does the actual computation. Here, we are assigning the type of vector for each column in `asv` and appending the column name to each vector element in `loop_output`.

!!! warning "Pre-allocating outputs"

    It is very important that you create an output vector of a known length/size prior to assigning outputs of an iteration. This is because by creating the vector first, you allocate some memory to store the output. Technically, you can populate a vector of length 0 like so:

    !!! r-project "code"

        ```r
        loop_output <- c()

        for (i in seq_along(asv)) {
          loop_output[i] <- typeof(asv[[i]])
          names(loop_output)[i] <- names(asv)[i]
        }
        ```
    
    **This is not advisable.** If you had a loop that would produce voluminous outputs, you would wait for it to iterate for a long time only for the programme to terminate because there was insufficient memory.

    If you truly do not know the exact size of the output *a priori* because you implement some control flow within the loop, you should know the maximum number of elements the loop would produce (we will try this below). In this case, create a vector of such a size then filter out the empty elements in post-processing. This is much safer than allowing the code to append outputs *ad infinitum*.

### Different kinds of loop construction

The first loop example is an iteration over a sequence of numbers. More specifically, it was an iteration over the indices of the columns of a data frame (i.e., iterating over column 1, then column 2, then column 3, etc.). Iterating over a sequence of numbers is quite natural and intuitive as it resembles counting: compute this on item 1, on item 2, on item 3, ...on item N. 

That is not the only way to iterate over a vector. You could also iterate over the elements themselves.

!!! r-project "code"

    ```r
    for (i in asv) {
      if (is.numeric(i)) {
        plot(
          density(log(i))
        )
      }
    }
    ```

    ??? success "Example output"

        ![density plot log i](figures/2.density_plot_log_i.png){width="600"}      

The code above iterates over the columns of our `asv` data frame and produces a density plot for logarithmic transform of each numeric column (i.e., the distribution of ASVs in log-scale). Notice that the title is not informative (we don't know which sample this is), and we've made 21 of these!

> If you added `main = i` to the plot, it will assign the entire column vector as the title across the middle of the plot. Not very informative, but maybe cool t-shirt design?

Another way to produce a similar plot is to iterate the names of a vector.

!!! r-project "code"

    ```r
    for (i in names(asv)) {
      if (is.numeric(asv[[i]])) {
        plot(
          density(log(asv[[i]])), main = i
        )
      }
    }
    ```

    ??? success "Example output"

        ![density plot log i with title](figures/2.density_plot_log_i_S3C3.png){width="600"}

This is useful for this particular case, but not so much for vectors without named elements. More often than not, iterating over indices is the most useful way to construct a loop sequence as we can capture both the vector and its name.

!!! r-project "code"

    ```r
    for (i in seq_along(asv)) {
      if (is.numeric(asv[[i]])) {
        plot(
          density(log(asv[[i]])), main = names(asv)[i]
        )
      }
    }
    ```

!!! tip "Iterate along rows"

    In the above examples, we used `seq_along()` to iterate each column of the `asv` data frame. To iterate along the rows, you can modify the sequence to this:

    !!! r-project "code"
    
        ```r
        for (i in seq_len(nrow(asv))) {
          x <- as.numeric(asv[i, -1])
          nx <- asv[i, 1]
          plot(
            density(log(x)), main = nx
          )
        }
        ```

### Nested lists and multiple outputs

```r
diversity_indices <- c("richness", "shannon", "simpson", "invsimpson")

sample_diversity <- vector(mode = "list", length = length(diversity_indices))
names(sample_diversity) <- diversity_indices

for (i in diversity_indices) {
  for (j in seq_along(asv)) {
    if (is.numeric(asv[[j]])) {
      sample_diversity[[i]][j] <- diversity_index(asv[[j]], index = i)
      names(sample_diversity[[i]])[j] <- names(asv)[j]
    }
  }
}
```

```r
sample_diversity <- bind_rows(sample_diversity)
```
